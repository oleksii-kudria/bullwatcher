# main.py
import os
from datetime import datetime
import argparse
import pandas as pd
import yfinance as yf
from ta.momentum import RSIIndicator
import requests
from config import (
    TICKERS,
    RSI_THRESHOLD,
    PRICE_DROP_THRESHOLD,
    RESULT_DIR,
    TELEGRAM_BOT_TOKEN,
    TELEGRAM_CHAT_ID,
)
import numpy as np
import re

def escape_markdown(text):
    if not isinstance(text, str):
        text = str(text)
    return re.sub(r'([_\*\[\]()~`>#+\-=|{}.!])', r'\\\1', text)

def get_stock_data(ticker):
    data = yf.download(ticker, period="2mo", interval="1d", auto_adjust=True)
    data.dropna(inplace=True)
    return data

def analyze_stock(ticker):
    df = get_stock_data(ticker)

    if df.empty or 'Close' not in df:
        return {'Ticker': ticker, 'Error': 'No data'}

    try:
        current_price = df['Close'].iloc[-1].item()
        month_open_price = df['Close'].iloc[0].item()
        price_change = ((current_price - month_open_price) / month_open_price) * 100

        close_series = df['Close']
        if isinstance(close_series, pd.DataFrame):
            close_series = close_series.squeeze()

        rsi_series = RSIIndicator(close_series, window=14).rsi()
        rsi = rsi_series.iloc[-1]

        if pd.isna(rsi):
            return {'Ticker': ticker, 'Error': 'RSI is NaN'}

        avg_30d = df['Close'].rolling(window=30).mean().iloc[-1]
        below_avg = current_price < avg_30d

        ticker_obj = yf.Ticker(ticker)
        try:
            info = ticker_obj.info
            recommendation = info.get('recommendationKey', 'n/a')
            target_mean_price = info.get('targetMeanPrice', None)
            long_name = info.get('longName', '')
            sector = info.get('sector', 'Unknown')
        except Exception:
            recommendation = 'n/a'
            target_mean_price = None
            long_name = ''
            sector = 'Unknown'

        return {
            'Ticker': ticker,
            'Company': long_name,
            'Sector': sector,
            'Current Price': round(current_price, 2),
            'Open Price (month)': round(month_open_price, 2),
            'Price Change %': round(price_change, 2),
            'RSI': round(float(rsi), 2),
            'Below 30d Avg': below_avg,
            'RSI_check': float(rsi) < RSI_THRESHOLD,
            'Drop_check': price_change <= -PRICE_DROP_THRESHOLD,
            'Recommendation': recommendation,
            'Target Mean Price': round(target_mean_price, 2) if target_mean_price is not None else None,
            'Error': None
        }

    except Exception as e:
        return {'Ticker': ticker, 'Error': str(e)}

def send_telegram_message(message):
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {
        'chat_id': TELEGRAM_CHAT_ID,
        'text': message,
        'parse_mode': 'Markdown'
    }
    try:
        requests.post(url, data=payload)
    except Exception as e:
        print(f"Telegram notification failed: {e}")

def format_sector_reports(df):
    df = df.copy()
    if 'Recommendation' in df.columns:
        df['Recommendation'] = df['Recommendation'].fillna('n/a').astype(str)
    df = df[df['Error'].isnull()] if 'Error' in df.columns else df
    df['Sector'] = df['Sector'].fillna('Unknown')
    sector_groups = df.groupby('Sector')
    messages = []

    legend_message = (
        "\U0001F4D8 *–ü–æ—è—Å–Ω–µ–Ω–Ω—è –¥–æ –∑–≤—ñ—Ç—É –ø–æ –∞–∫—Ü—ñ—è—Ö*\n\n"
        "üìä *–û—Ü—ñ–Ω–∫–∞ —Å–∏–≥–Ω–∞–ª—É –∫—É–ø—ñ–≤–ª—ñ:*\n"
        "- üî• ‚Äì *–°–∏–ª—å–Ω–∏–π —Å–∏–≥–Ω–∞–ª*: RSI < 40, –ø–∞–¥—ñ–Ω–Ω—è ‚â• 5%, —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—è Buy/Strong Buy.\n"
        "- ‚úÖ ‚Äì *–ü–æ–º—ñ—Ä–Ω–∏–π —Å–∏–≥–Ω–∞–ª*: –≤–∏–∫–æ–Ω–∞–Ω–æ 2 –∑ 3 —É–º–æ–≤.\n"
        "- ‚ö†Ô∏è ‚Äì *–°–ª–∞–±–∫–∏–π —Å–∏–≥–Ω–∞–ª*: –ª–∏—à–µ 1 —É–º–æ–≤–∞.\n"
        "- ‚ùå ‚Äì *–ù–µ–º–∞—î —Å–∏–≥–Ω–∞–ª—É*: –Ω–µ –≤–∏–∫–æ–Ω–∞–Ω–æ –∂–æ–¥–Ω–æ—ó —É–º–æ–≤–∏.\n\n"
        "üìâ *–û—Ü—ñ–Ω–∫–∞ –∑–∞ RSI:*\n"
        "- üßä ‚Äì RSI < 30: –ø–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–∞, –º–æ–∂–ª–∏–≤–∏–π —Ä—ñ—Å—Ç.\n"
        "- üìâ ‚Äì RSI < 40: –ø–æ—Ç–µ–Ω—Ü—ñ–∞–ª –¥–æ –∑—Ä–æ—Å—Ç–∞–Ω–Ω—è.\n"
        "- ‚öñÔ∏è ‚Äì RSI 40‚Äì70: –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∞ –∑–æ–Ω–∞.\n"
        "- üî∫ ‚Äì RSI > 70: –ø—ñ–¥–≤–∏—â–µ–Ω–∏–π –æ–ø—Ç–∏–º—ñ–∑–º.\n"
        "- üö´ ‚Äì RSI > 80: –ø–µ—Ä–µ–≥—Ä—ñ—Ç–∞ –∞–∫—Ü—ñ—è.\n\n"
        "‚ö†Ô∏è *–Ü–Ω—à—ñ –º–∞—Ä–∫–µ—Ä–∏ —Ä–∏–∑–∏–∫—É:*\n"
        "- üíß ‚Äì –ó–º—ñ–Ω–∞ < 2%: —Å—Ç–∞–±—ñ–ª—å–Ω–∞ –¥–∏–Ω–∞–º—ñ–∫–∞.\n"
        "- ‚ö° ‚Äì –ó–º—ñ–Ω–∞ > 30%: –≤–∏—Å–æ–∫–∞ –≤–æ–ª–∞—Ç–∏–ª—å–Ω—ñ—Å—Ç—å.\n"
        "üìà –°—Ç—Ä—ñ–ª–∫–∏ –≤–≥–æ—Ä—É/–≤–Ω–∏–∑ –≤—ñ–¥–æ–±—Ä–∞–∂–∞—é—Ç—å –Ω–∞–ø—Ä—è–º –∑–º—ñ–Ω–∏ —Ü—ñ–Ω–∏: üîºüü¢ ‚Äì –∑—Ä–æ—Å—Ç–∞–Ω–Ω—è, üîΩüî¥ ‚Äì –ø–∞–¥—ñ–Ω–Ω—è."
    )
    messages.append(legend_message)

    for sector, group in sector_groups:
        message = f"\U0001F4CB *–ó–≤—ñ—Ç –ø–æ –≥–∞–ª—É–∑—ñ: {escape_markdown(sector)}*"
        for _, row in group.iterrows():
            rec = escape_markdown(row['Recommendation'].capitalize() if row['Recommendation'] != 'n/a' else '–ë–µ–∑ –¥–∞–Ω–∏—Ö')
            rsi = float(row['RSI'])
            change = float(row['Price Change %'])
            direction = "üîºüü¢" if change > 0 else "üîΩüî¥"

            rsi_flag = rsi < 40
            drop_flag = change <= -5
            rec_flag = row['Recommendation'] in ['buy', 'strong_buy']
            score = sum([rsi_flag, drop_flag, rec_flag])

            if score == 3:
                emoji = 'üî•'
            elif score == 2:
                emoji = '‚úÖ'
            elif score == 1:
                emoji = '‚ö†Ô∏è'
            else:
                emoji = '‚ùå'

            risk_emoji = ''
            if rsi > 80:
                risk_emoji += " üö´ –ü–µ—Ä–µ–≥—Ä—ñ—Ç–∞"
            elif rsi < 30:
                risk_emoji += " üßä –ü–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–∞"
            elif rsi < 40:
                risk_emoji += " üìâ –ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª"
            elif 40 <= rsi <= 70:
                risk_emoji += " ‚öñÔ∏è –ù–µ–π—Ç—Ä–∞–ª—å–Ω–∞"
            elif rsi > 70:
                risk_emoji += " üî∫ –û–ø—Ç–∏–º—ñ–∑–º"

            if change > 30:
                risk_emoji += " ‚ö° –í–∏—Å–æ–∫–∞ –≤–æ–ª–∞—Ç–∏–ª—å–Ω—ñ—Å—Ç—å"
            elif abs(change) < 2:
                risk_emoji += " üíß –°—Ç–∞–±—ñ–ª—å–Ω–∞"

            ticker = escape_markdown(row['Ticker'])
            name = escape_markdown(row['Company']) if row['Company'] else ''
            msg_line = f"\n{emoji} *{ticker}* {name}: ${row['Current Price']} | –ó–º—ñ–Ω–∞: {direction} {abs(row['Price Change %'])}% | RSI: {row['RSI']}{risk_emoji} | –†–µ–∫–æ–º: {rec}"
            if row['Target Mean Price'] is not None:
                msg_line += f" | üéØ ${row['Target Mean Price']}"
            message += msg_line

        messages.append(message)

    return messages

def top_recommendations(df, limit=5):
    df = df.copy()
    if 'Recommendation' in df.columns:
        df['Recommendation'] = df['Recommendation'].fillna('n/a').astype(str)

    df = df[df['Error'].isnull() & df['Target Mean Price'].notnull()]
    df['Score'] = (
        (df['RSI'] < 40).astype(int) +
        (df['Price Change %'] <= -5).astype(int) +
        (df['Recommendation'].isin(['buy', 'strong_buy'])).astype(int)
    )
    df = df[df['Score'] >= 2]
    df['Potential %'] = ((df['Target Mean Price'] - df['Current Price']) / df['Current Price']) * 100
    df = df.sort_values(by=['Score', 'Potential %'], ascending=[False, False]).head(limit)

    message = "\U0001F4A1 *–ù–∞–π–ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–Ω—ñ—à—ñ –∞–∫—Ü—ñ—ó –¥–ª—è –∫—É–ø—ñ–≤–ª—ñ:*"
    for _, row in df.iterrows():
        ticker = escape_markdown(row['Ticker'])
        name = escape_markdown(row['Company'])
        rec = escape_markdown(row['Recommendation'].capitalize())
        pot = round(row['Potential %'], 2)
        message += f"\n- *{ticker}* {name} | –ü–æ—Ç–µ–Ω—Ü—ñ–∞–ª: +{pot}% | –†–µ–∫–æ–º: {rec} | üéØ ${row['Target Mean Price']}"
    return message

def collect_data():
    """Collect fresh stock data and save it to today's CSV file."""
    today = datetime.now().strftime('%Y-%m-%d')
    output_dir = os.path.join(os.getcwd(), RESULT_DIR)
    os.makedirs(output_dir, exist_ok=True)

    results = [analyze_stock(ticker) for ticker in TICKERS]
    df = pd.DataFrame(results)

    output_path = os.path.join(output_dir, f"{today}.csv")
    df.to_csv(output_path, index=False)
    return df


def load_or_collect():
    """Load today's data if available, otherwise collect it."""
    today = datetime.now().strftime('%Y-%m-%d')
    output_path = os.path.join(os.getcwd(), RESULT_DIR, f"{today}.csv")
    if os.path.exists(output_path):
        df = pd.read_csv(output_path)
    else:
        df = collect_data()

    # Ensure recommendation values are strings
    if 'Recommendation' in df.columns:
        df['Recommendation'] = df['Recommendation'].fillna('n/a').astype(str)

    return df


def report_console():
    df = load_or_collect()
    for msg in format_sector_reports(df):
        print(msg)


def report_telegram():
    df = load_or_collect()
    for msg in format_sector_reports(df):
        send_telegram_message(msg)


def offer_console():
    df = load_or_collect()
    print(top_recommendations(df))


def offer_telegram():
    df = load_or_collect()
    send_telegram_message(top_recommendations(df))


def main():
    parser = argparse.ArgumentParser(description="Stock analysis utility")
    parser.add_argument(
        "command",
        choices=[
            "collect",
            "report_console",
            "report_telegram",
            "offer_console",
            "offer_telegram",
        ],
        help="Action to perform",
    )
    args = parser.parse_args()

    if args.command == "collect":
        collect_data()
    elif args.command == "report_console":
        report_console()
    elif args.command == "report_telegram":
        report_telegram()
    elif args.command == "offer_console":
        offer_console()
    elif args.command == "offer_telegram":
        offer_telegram()

if __name__ == "__main__":
    main()
